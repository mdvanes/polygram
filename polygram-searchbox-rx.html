<!--<link rel="import" href="../marked-element/marked-element.html">-->
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<!--<link rel="import" href="../iron-ajax/iron-ajax.html">-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="polygram-element-styles.html">
<script src="../rxjs/dist/rx.lite.js"></script>

<dom-module id="polygram-searchbox-rx">
    <template>
        <!--<style>
            :host {
                display: block;
            }
        </style>-->
        <style include="polygram-element-styles"></style>
        <style>
            :root {
                --btn-toggle-color: #3335FF;
                --btn-toggle-border-color: #3C70FF;
            }
        </style>
        <div>
            <h2>Search (rx) [[sourceName]]!</h2>
            <paper-input id="searchFetchInput" label="search with Fetch" on-change="fakeSearchAction">
                <iron-icon icon="close" slot="prefix"></iron-icon>
            </paper-input>
            <!--<button id="btn-toggle" on-click="toggle">toggle [[isOpen]]</button>-->
            <!--<div class="test-class-toggling">-->
                <!--<div class$="{{_toggleClass}}">-->
                    <!--test class$-->
                <!--</div>-->
            <!--</div>-->
            <template is="dom-if" if="{{isOpen}}">
                <div class="external-css">test external-css and dom-if</div>
            </template>
            <!--<ul id="searchResults"></ul>-->
            <ul>
                <template is="dom-repeat" items="{{_searchResultsFetchArr}}">
                    <!--<li>a [[index]] [[item.title]]</li>-->
                    <li>[[item.title]]</li>
                </template>
            </ul>
            <!--<paper-input id="searchIAInput"-->
                         <!--value="{{_searchIAInput}}"-->
                         <!--label="search with iron-ajax" charcounter="true" maxlength="100">-->
                <!--<iron-icon icon="close" slot="prefix"></iron-icon>-->
            <!--</paper-input>-->
            <!--<ul>-->
                <!--<template is="dom-repeat" items="{{_searchResultsIAArr}}">-->
                    <!--<li>[[index]]. [[item.title]]</li>-->
                <!--</template>-->
            <!--</ul>-->
            <!--<iron-request id="xhr"></iron-request>-->
            <!--&lt;!&ndash;-->
             <!--Without auto, call manually with:-->
              <!--this.$.searchIARequest.generateRequest() in e.g. ready()-->
            <!--&ndash;&gt;-->
            <!--<iron-ajax-->
                    <!--auto-->
                    <!--id="searchIARequest"-->
                    <!--url="{{_searchIAUrl}}"-->
                    <!--handle-as="json"-->
                    <!--debounce-duration="500"-->
                    <!--on-response="_searchIAHandler"></iron-ajax>-->
        </div>

    </template>

    <script>
        /**
         * `polygram-searchbox-rx`
         * load photos in instagram style
         *
         * @customElement
         * @polymer
         * @demo demo/index.html
         */
        class PolygramSearchboxRx extends Polymer.Element {
            static get is() {
                return 'polygram-searchbox-rx';
            }

            static get properties() {
                return {
                    sourceName: {
                        type: String,
                        value: 'polygram-searchbox-rx'
                    },
                    isOpen: {
                        type: Boolean,
                        value: false,
                        observer: '_isOpenChanged'
                    },
                    staticOpen: {
                        type: Boolean,
                        value: false
                    },
                    _toggleClass: {
                        type: String,
                        value: ''
                    },
                    _searchResultsFetchArr: {
                        type: Array,
                        value: []
                    },
//                    _searchIAInput: {
//                        type: String,
//                        value: null,
//                        observer: '_searchIAInputChanged'
//                    },
//                    _searchIAUrl: {
//                        type: String,
//                        value: null
//                    },
//                    _searchResultsIAArr: {
//                        type: Array,
//                        value: []
//                    }
                };
            }

//            /**
//             * Toggle the info block
//             */
//            toggle() {
//                //console.log('toggle isopen', this.isOpen);
//                this.set('isOpen', !this.isOpen);
//            }

            _bindSearchObservableFetch() {
                //console.log('_bindSearchObservable', this);
                const observable = Rx.Observable.fromEvent(this.$.searchFetchInput, 'keyup')
                    .map(e => e.target.value) // the complete value of the input elem
                    .filter(text => text.length > 2 ) // only if longer than 2 chars
                    //.debounceTime(750) // pause for 750 ms // TODO this is somehow not included in the rx.lite.js import
                    .distinctUntilChanged(); // only if changed

                // FlatMapLatest has been replaced by SwitchMap: Map to observable, complete previous inner observable, emit values.
                // Needed to keep this context in _searchWikipedia
                const searcher = observable.switchMap(term => this._searchWikipediaFetch(term));
                //const searcher = observable.switchMap(this._searchWikipedia);

                // TODO test `polymer build --preset es6-bundled`
                // TODO test the ING the guide starter kit for Polymer!

                searcher.subscribe(data => {
                    //console.log('subscribe response:', data);
                    // TODO do results by creating result HTML with Polymer
                    //this.$.searchResults.innerText = '';
                    this._searchResultsArr = [];
                    if(data) {
                        //console.log('query result', data.query.pages[4576465].images);
                        // results
                        //     //.empty()
                        //     .append =
                        //console.log('query result', data.query);
                        // Search for "flower"
//                        data.query.search.map(item => {
//                        //data.query.pages[4576465].images.map(item => {
//                            //console.log(item);
//                            //return `<li>${item.title}</li>`;
//                            const li = document.createElement('li');
//                            li.innerHTML = item.title;
//                            return li;
//                        })
//                        .forEach(item => this.$.searchResults.appendChild(item));
                        // TODO accept data.query.pages.*.images
                        this._searchResultsFetchArr = data.query.search.map(item => {
                            //console.log('_searchResultsArr', item);
                            // TODO render images
                            return {title: item.title};
                        });
                    } else {
                        console.error('data is empty');
                    }
                })
            }

            _searchWikipediaFetch(term) {
                console.log(`searching Wikipedia for ${term}`);
                //term = 'flower';
                // TODO solve using iron-ajax. The following is called on each change, but only fires one request
                // It is not possible with iron-request (see https://medium.com/@fokusman/how-to-make-ajax-calls-in-polymer-js-8ba6b893ebf8)
                // This would involve using iron-ajax with auto=on and the url a property that is observed. The response
                // could be set with the callback function to another property which can also be observed, and this would
                // remove the need and possibility to use Rx. So make maybe two search under each other with the two different
                // implementations
//                this.$.xhr
//                    .send({
//                        // wikipedia articles
//                        url: `https://cors-anywhere.herokuapp.com/en.wikipedia.org:443/w/api.php?action=query&format=json&list=search&srsearch=${encodeURI(term)}`,
//                        // wikipedia images
//                        //url: `https://cors-anywhere.herokuapp.com/en.wikipedia.org:443/w/api.php?action=query&format=json&titles=${encodeURI(term)}&prop=images`,
////                        body: {
////                            foo: 'bar'
////                        },
//                        handleAs: 'json'
//                    });
//                return this.$.xhr.completes
//                    .then(xhrElem => {
//                        //console.log('response', this.$.xhr.response, xhrElem.response);
//                        return xhrElem.response;
//                    })
//                    .catch(err => console.error('Failed calling wikipedia'));

                // Normal working Fetch
                return fetch(`https://cors-anywhere.herokuapp.com/en.wikipedia.org:443/w/api.php?action=query&format=json&list=search&srsearch=${encodeURI(term)}`, {
                    method: 'GET',
                    //mode: 'no-cors',
                    dataType: 'json',
                    headers: {
                        Accept: 'application/json',
                    },
                })
                    .then(response => {
                        if(response.ok) {
                            // https://stackoverflow.com/questions/36840396/react-fetch-gives-an-empty-response-body
                            return response.json(); // <- this might fail because no-cors returns an opaque response: https://stackoverflow.com/questions/36840396/react-fetch-gives-an-empty-response-body
                        }
                        console.error('response error');
                    })
                    .catch(err => console.error('Invalid JSON:', err));

//                return Rx.Observable.fromPromise(fetch(`https://cors-anywhere.herokuapp.com/en.wikipedia.org:443/w/api.php?action=query&format=json&list=search&srsearch=${encodeURI(term)}`, {
//                    method: 'GET',
//                    //mode: 'no-cors',
//                    dataType: 'json',
//                    headers: {
//                        Accept: 'application/json',
//                    },
//                }));
//                this.$.searchRequest.generateRequest();
            }

//            _searchHandler() {
//                console.log(response);
//            }

//            _searchIAInputChanged(term) {
//                //console.log(term);
//                if(term && term.length > 0) {
//                    this._searchIAUrl = `https://cors-anywhere.herokuapp.com/en.wikipedia.org:443/w/api.php?action=query&format=json&list=search&srsearch=${encodeURI(term)}`;
//                }
//            }
//
//            _searchIAHandler(data) {
//                console.log(data, data.detail, data.detail.response);
//                if(data && data.detail && data.detail.response && data.detail.response.query &&
//                data.detail.response.query.search) {
//                    this._searchResultsIAArr = data.detail.response.query.search;
//                }
//            }

            // TODO use Polymer property observer with rxjs?

            _isOpenChanged() {
                this._toggleClass = '';
                if(this.isOpen) {
                    this._toggleClass = 'opened';
                }
            }

            ready() {
                super.ready();
                //this.isOpen = this.staticOpen;
                this._bindSearchObservableFetch();
            }

//            fakeSearchAction() {
//                console.log(`fakesearching "${this.$.searchFetchInput.value}".`);
//            }

            /*searchAction() {
                this.searchService(this.$.searchInput.value);
            }*/

        }

        window.customElements.define(PolygramSearchboxRx.is, PolygramSearchboxRx);
    </script>
</dom-module>
